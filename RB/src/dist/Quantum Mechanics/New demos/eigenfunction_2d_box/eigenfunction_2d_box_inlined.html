<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8"/>
<link crossorigin="anonymous" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css" integrity="sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X" rel="stylesheet"/>
<!-- The loading of KaTeX is deferred to speed up page rendering -->
<script crossorigin="anonymous" defer="" integrity="sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4" onload="renderLatex()" src="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js"></script>
<script crossorigin="anonymous" integrity="sha512-C2RveGuPIWqkaLAluvoxyiaN1XYNe5ss11urhZWZYBUA9Ydgj+hfGKPcxCzTwut1/fmjEZR7Ac35f2aycT8Ogw==" src="https://cdnjs.cloudflare.com/ajax/libs/d3/6.2.0/d3.min.js"></script>
<script crossorigin="anonymous" integrity="sha512-hYTm5fiLwl7dI0CCvHmXeekhxHTYeVlHSd/HDjc1hlO/SFSitk2Zy289ChHW+ihHhx5WK8XzkiLHaApwngC22w==" src="https://cdn.plot.ly/plotly-1.57.0.min.js"></script>
<style rel="stylesheet">:root {
--color-highlight: #5df;
--color-secondary: #f3c002;
--color-tertiary: #14c778;
--color-quaternary: #e5d;
--color-graphic-primary: #27f;
}
body {
/* margin-left: 10px;
margin-top: 10px; */
background-color: black;
color: white;
font-size: 22px;
font-family: sans-serif;
line-height: 1.8em;
}
.grid-left-right {
display: grid;
grid-template-columns: 13em 1fr;
align-items: start;
column-gap: 40px;
}
.grid-left-right-2 {
display: grid;
grid-template-columns: max-content 1fr;
align-items: start;
column-gap: 40px;
}
.controls-container {
display: inline-block;
border: 2px solid white;
border-radius: 5px;
padding: 10px;
}
.controls {
grid-row: span 2;
display: grid;
grid-template-columns: 1fr;
row-gap: 2px;
}
.controls > :nth-child(2n + 3) {
margin-top: 30px;
}
.controls-grid {
display: grid;
grid-template-columns: max-content 1fr;
column-gap: 20px;
row-gap: 5px;
}
.draggable:hover {
cursor: grab;
}
.draggable:active {
cursor: grabbing;
}
.graph-key {
display: grid;
grid-template-columns: 30px 1fr;
align-items: center;
column-gap: 20px;
background-color: black;
padding: 15px 6px;
border-radius: 4px;
border: black solid 2px;
}
.key-line {
height: 7px;
width: 40px;
}
/* Legacy; don't use */
.slider-container {
grid-row: span 2;
display: grid;
grid-template-columns: 1fr;
row-gap: 2px;
}
/* Legacy; don't use */
.slider-container > :nth-child(2n + 3) {
margin-top: 30px;
}
.param-slider-container {
display: inline-block;
width: 100%;
}
input[type="range"] {
width: 100%;
}
.plot {
display: inline-block;
}
.plot-container {
display: grid;
grid-template-columns: 1fr 1fr;
column-gap: 10px;
}
.axis {
stroke-width: 3;
stroke: #aaa;
}
.axis-tick {
stroke-width: 3;
stroke: #aaa;
}
.axis-label {
stroke-opacity: 0;
fill: #ddd;
font-size: 17px;
}
.x-axis-label {
text-anchor: middle;
dominant-baseline: hanging;
}
.y-axis-label {
text-anchor: end;
dominant-baseline: middle;
}
.math {
color: black;
background-color: white;
padding: 9px 5px;
border-radius: 2px;
/* border: 1px solid white; */
}
.radio-button-container label input {
display: none;
}
.radio-button-container.horizontal {
display: flex;
flex-direction: row;
align-content: stretch;
line-height: initial;
}
.radio-button-container button {
flex: 1;
}
.radio-button-container.vertical {
display: flex;
flex-direction: column;
/* align-content: stretch;
line-height: initial; */
}
.button {
padding: 7px 8px;
margin-right: 3px;
font-size: 15px;
border-radius: 4px;
background: #ccc;
background-image: -webkit-linear-gradient(top, #fff, #aaa);
color: black;
text-shadow: 1px 1px #ddd;
}
.button:hover {
cursor: pointer;
}
.button:active {
background: #ccc;
background-image: -webkit-linear-gradient(top, #999, #fff);
color: #333;
}
.button:disabled {
background: #ccc;
background-image: -webkit-linear-gradient(top, #999, #aaa);
color: #444;
text-shadow: 1px 1px #ccc;
cursor: default;
}
.highlighted-text {
color: var(--color-highlight);
}
.secondary-text {
color: var(--color-secondary);
}
.tertiary-text {
color: var(--color-tertiary);
}
.quaternary-text {
color: var(--color-quaternary);
}
.viz-canvas {
padding-top: 1em;
}
.sci-num {
padding-right: 0.15em;
}
.eqn-left {
text-align: right;
}
.eqn-middle {
padding-left: 0.25em;
padding-right: 0.25em;
}
.eqn-right {
text-align: left;
}
.radio-label {
padding-left: 3px;
}
.subscript {
position: relative;
top: 0.3em;
left: 0;
font-size: 65%;
}
.superscript {
position: relative;
bottom: 0.8em;
left: 0;
font-size: 65%;
}
.minus-sign {
margin-right: 1px;
}
.operator {
margin-left: 3px;
margin-right: 3px;
}
button.depressed-button {
background-color: #555;
color: white;
}
input[type="radio"] {
position: relative;
bottom: 4px;
}
input[type="range"] {
-webkit-appearance: none;
-moz-apperance: none;
height: 8px;
padding: 0 0;
background: #8b8f92;
border-radius: 2px;
position: relative;
bottom: 4px;
outline: none;
}
input[type="range"]:disabled {
opacity: 0.5;
}
input[type="range"]::-webkit-slider-thumb {
-webkit-appearance: none;
-moz-apperance: none;
width: 25px;
height: 25px;
-webkit-border-radius: 20px;
-moz-border-radius: 20px;
-ms-border-radius: 20px;
-o-border-radius: 20px;
border-radius: 20px;
background-image: -webkit-gradient(
linear,
left top,
left bottom,
color-stop(0, #fefefe),
color-stop(0.49, #d7d7d7),
color-stop(0.51, #d1d1d1),
color-stop(1, #c8c8c8)
);
border: 1px solid #787878;
}
input[type="range"]::-moz-range-thumb {
box-shadow: 1px 1px 1px #000000, 0 0 1px #0d0d0d;
border: 1px solid #000000;
height: 20px;
width: 20px;
border-radius: 20px;
background: #ffffff;
cursor: pointer;
}
/* All the same stuff for IE */
input[type="range"]::-ms-thumb {
box-shadow: 1px 1px 1px #000000, 0 0 1px #0d0d0d;
border: 1px solid #000000;
height: 20px;
width: 20px;
border-radius: 20px;
background: #ffffff;
cursor: pointer;
}
</style><style>
.button {
flex-grow: 1;
}
.latex {
font-size: 18px;
}
.grid-top-bottom {
display: grid;
grid-template-rows: 1fr 100px;
row-gap: 20px;
}
.controls-container {
width: 300px;
}
.grid-left-right {
column-gap: 200px;
overflow-x: visible;
}
.eqn-container {
/* position: relative; */
white-space: nowrap;
line-height: 80px;
min-height: 100%;
height: 150px;
z-index: 999;
}
.eqn-spacer {
display: inline-block;
width: 70px;
}
.plot-container {
max-height: 800px;
vertical-align: top;
overflow-y: hidden;
z-index: -999;
}
#plot {
position: relative;
top: -50px;
left: -50px;
}
</style></head>
<body>
<div class="grid-left-right">
<div class="grid-top-bottom">
<div class="controls-container">
<div class="controls">
<span>ùëõ<sub>ùë•</sub></span>
<div class="radio-button-container horizontal">
<button axis="x" button-checked="" class="button n-button" id="btn-nx-1" wavenumber="1">
1</button><button axis="x" class="button n-button" id="btn-nx-2" wavenumber="2">
2</button><button axis="x" class="button n-button" id="btn-nx-3" wavenumber="3">
3</button><button axis="x" class="button n-button" id="btn-nx-4" wavenumber="4">
4</button><button axis="x" class="button n-button" id="btn-nx-5" wavenumber="5">
5
</button>
</div>
<span>ùëõ<sub>ùë¶</sub></span>
<div class="radio-button-container horizontal">
<button axis="y" button-checked="" class="button n-button" id="btn-ny-1" wavenumber="1">
1</button><button axis="y" class="button n-button" id="btn-ny-2" wavenumber="2">
2</button><button axis="y" class="button n-button" id="btn-ny-3" wavenumber="3">
3</button><button axis="y" class="button n-button" id="btn-ny-4" wavenumber="4">
4</button><button axis="y" class="button n-button" id="btn-ny-5" wavenumber="5">
5
</button>
</div>
<span>ùëé</span>
<span><input class="length-slider" id="slider-lx" type="range"/></span>
<span>ùëè</span>
<span><input class="length-slider" id="slider-ly" type="range"/></span>
</div>
</div>
<div class="eqn-container math">
<span class="latex" id="text-eqn-wavefunction"></span><br/><span class="latex" id="text-eqn-energy"></span>
</div>
</div>
<div>
<div class="plot-container">
<div class="draggable" id="plot"></div>
</div>
</div>
</div>
<script type="text/javascript">"use strict";
// eslint-disable-next-line no-unused-vars
const C = 299792458;
// eslint-disable-next-line no-unused-vars
const HL_COLOR = "#5df";
// eslint-disable-next-line no-unused-vars
const STANDARD_COLORS = {
highlighted: "#5df", // cyan used for variables
secondary: "#f3c002", // yellow
tertiary: "#14c778", // green
quaternary: "#e5d", // pinkish
graphicPrimary: "#27f", // brilliant blue
};
// https://stackoverflow.com/a/32538867
// eslint-disable-next-line no-unused-vars
function isIterable(obj) {
// checks for null and undefined
if (obj === null || typeof obj === "undefined") {
return false;
}
return typeof obj[Symbol.iterator] === "function";
}
function applyDatum(datum, { transition } = {}) {
const d3Obj = d3.select(this);
d3Obj.datum(datum);
if (
(datum.class !== undefined || datum.classes !== undefined) &&
this.hasAttribute("class")
) {
this.removeAttribute("class");
}
if (typeof datum.class !== "undefined") {
d3Obj.classed(datum.class, true);
}
if (typeof datum.classes !== "undefined") {
for (const c of datum.classes) {
d3Obj.classed(c, true);
}
}
const t = typeof transition === "undefined" ? d3Obj : d3Obj.transition(transition);
if (datum.attrs !== undefined) {
Object.entries(datum.attrs).forEach(([key, val]) => {
t.attr(key, val);
});
}
if (datum.styles !== undefined) {
Object.entries(datum.styles).forEach(([key, val]) => {
t.style(key, val);
});
}
if (typeof datum.text !== "undefined") {
d3Obj.text(datum.text);
}
if (typeof datum.children !== "undefined") {
// eslint-disable-next-line no-use-before-define
applyGraphicalObjs(d3Obj, () => datum.children, { selector: "*", transition });
}
}
// eslint-disable-next-line no-unused-vars
function _addGraphicalObjs(sel, dataFunc) {
return sel
.selectAll()
.data(dataFunc)
.enter()
.append(d => d3.create(`svg:${d.shape}`).node())
.each(applyDatum);
}
// eslint-disable-next-line no-unused-vars
function applyGraphicalObjs(sel, data, { key, selector, cssClass, transition } = {}) {
const s = sel
.selectAll(selector)
.data(data, key)
.join(
enter => enter.append(d => d3.create(`svg:${d.shape}`).node()),
update => update,
exit =>
(transition !== undefined
? exit.transition(transition).style("opacity", 0)
: exit
).remove(),
)
.each(function (d) {
applyDatum.call(this, d, { transition });
});
if (typeof cssClass !== "undefined") {
s.classed(cssClass, true);
}
return s;
}
// eslint-disable-next-line no-unused-vars
function lorentzFactor({ fracOfC }) {
if (!fracOfC) {
fracOfC = 0;
}
return 1 / Math.sqrt(1 - fracOfC * fracOfC);
}
// eslint-disable-next-line no-unused-vars
function sign(x, epsilon) {
if (typeof epsilon === "undefined") {
epsilon = 1e-6;
}
return x < -epsilon ? -1 : x < epsilon ? 0 : 1;
}
// eslint-disable-next-line no-unused-vars
function l2Norm(...vector) {
const sum = vector.reduce((accum, currVal) => accum + currVal * currVal, 0);
return Math.sqrt(sum);
}
function __matMulHelper(mat1, mat2) {
if (typeof mat1[0].length === "undefined") {
mat1 = [mat1];
}
const squeezeAns = typeof mat2[0].length === "undefined";
if (squeezeAns) {
mat2 = mat2.map(elem => [elem]);
}
const m = mat1.length;
const k = mat2.length;
const n = mat2[0].length;
const ans = [];
for (let r = 0; r < m; ++r) {
const rowAns = [];
for (let c = 0; c < n; ++c) {
let sum = 0;
for (let i = 0; i < k; ++i) {
sum += mat1[r][i] * mat2[i][c];
}
rowAns.push(sum);
}
ans.push(rowAns);
}
if (squeezeAns) {
return ans.map(row => row[0]);
}
return ans;
}
// eslint-disable-next-line no-unused-vars
function matMul(...mats) {
let ans = mats[0];
for (let i = 1; i < mats.length; ++i) {
ans = __matMulHelper(ans, mats[i]);
}
return ans;
}
// eslint-disable-next-line no-unused-vars
function defineArrowhead(defs, { id, length, width, color, attrs, flip }) {
attrs = attrs ?? {};
flip = flip ?? false;
const markerAttrs = {
attrs: {
refX: length / 2,
refY: width / 2,
markerUnits: "userSpaceOnUse",
markerWidth: length,
markerHeight: width,
orient: "auto",
},
};
const path = flip
? `M ${length - 1} 1 L 1 ${width / 2} L ${length - 1} ${width - 1} L ${
(2 * length) / 3
} ${width / 2} z`
: `M 1 1 L ${length - 1} ${width / 2} L 1 ${width - 1} L ${length / 3} ${
width / 2
} z`;
const arrowheadAttrs = {
attrs: {
d: path,
"stroke-linejoin": "miter",
stroke: color,
fill: color,
...attrs,
},
};
defs.append("svg:marker")
.attr("id", id)
.each(function () {
applyDatum.call(this, markerAttrs);
})
.append("svg:path")
.each(function () {
applyDatum.call(this, arrowheadAttrs);
});
}
// eslint-disable-next-line no-unused-vars
function groupBy(array, keyFunc, expectedKeys, asArray = true) {
const grouped = {};
for (const elem of array) {
const key = keyFunc(elem);
if (key in grouped) {
grouped[key].push(elem);
} else {
grouped[key] = [elem];
}
}
if (expectedKeys) {
for (const k of expectedKeys) {
if (!(k in grouped)) {
grouped[k] = [];
}
}
}
if (asArray) {
return Object.entries(grouped);
}
return grouped;
}
// We'll use x and y terminology to describe gridlines running parallel to the y axis,
// but of course you can swap x and y in the returned array to get gridlines in the
// other direction. Returns an array of gridlines; each gridline is an array of points
// [x,y]
// eslint-disable-next-line no-unused-vars
function getGridlines({
nGridlines,
xMin,
xMax,
yMin,
yMax,
zFunc,
drawEdges,
nPointsPerGridline,
swapOrientation,
}) {
drawEdges = drawEdges ?? false;
swapOrientation = swapOrientation ?? false;
if (swapOrientation) {
[xMin, yMin] = [yMin, xMin];
[xMax, yMax] = [yMax, xMax];
}
const iMin = drawEdges ? 0 : 1;
const iMaxPlus1 = drawEdges ? nGridlines : nGridlines - 1;
nPointsPerGridline = nPointsPerGridline ?? 51;
const dx = (xMax - xMin) / (nGridlines - 1);
const dy = (yMax - yMin) / (nPointsPerGridline - 1);
const gridlines = [];
for (let i = iMin; i < iMaxPlus1; ++i) {
const x = xMin + i * dx;
const gridline = [];
for (let j = 0; j < nPointsPerGridline; ++j) {
const y = yMin + j * dy;
let trueX, trueY;
if (!swapOrientation) {
trueX = x;
trueY = y;
} else {
trueX = y;
trueY = x;
}
const point =
zFunc !== undefined
? [trueX, trueY, zFunc(trueX, trueY)]
: [trueX, trueY];
gridline.push(point);
}
gridlines.push(gridline);
}
return gridlines;
}
// eslint-disable-next-line no-unused-vars
function sampleFromCdf(cdfPoints, n) {
n = n ?? 1;
const samples = [];
for (let i = 0; i < n; ++i) {
const r = Math.random();
let left = 0;
let right = cdfPoints.length - 1;
let currentIndex;
while (left < right - 1) {
currentIndex = Math.floor((left + right) / 2);
const currentPoint = cdfPoints[currentIndex];
const y = currentPoint[1];
if (y < r) {
left = currentIndex;
} else {
right = currentIndex;
}
}
let value;
if (currentIndex < cdfPoints.length - 1) {
const [x1, a1] = cdfPoints[currentIndex];
const [x2, a2] = cdfPoints[currentIndex + 1];
const t = (r - a1) / (a2 - a1);
value = (1 - t) * x1 + t * x2;
} else {
value = cdfPoints[currentIndex][0];
}
samples.push(value);
}
return samples;
}
function syncButtonState(button) {
if (button.hasAttribute("button-checked")) {
button.disabled = true;
} else if (button.disabled) {
button.setAttribute("button-checked", "");
}
}
function _initializeRadioButtons() {
const radioButtonContainers = document.getElementsByClassName(
"radio-button-container",
);
for (let i = 0; i < radioButtonContainers.length; ++i) {
const rbc = radioButtonContainers[i];
d3.select(rbc)
.selectAll("button")
.each(function () {
syncButtonState(this);
})
.on("click._default", function () {
this.setAttribute("button-checked", "");
this.disabled = true;
const siblings = this.closest(
".radio-button-container",
).querySelectorAll("button");
for (const sibling of siblings) {
if (this === sibling) {
continue;
}
sibling.disabled = false;
sibling.removeAttribute("button-checked");
}
});
}
}
_initializeRadioButtons();
</script><script type="text/javascript">/* global katex getGridlines STANDARD_COLORS Plotly */
// eslint-disable-next-line no-unused-vars
function renderLatex() {
document.getElementById("text-eqn-wavefunction").innerHTML = katex.renderToString(
`\\displaystyle\\psi(x,y)=\\sqrt{\\frac{2}{a}}\\sqrt{\\frac{2}{b}}\\sin\\left(\\frac{\\pi n_x x}{a}\\right)\\sin\\left(\\frac{\\pi n_y y}{b}\\right)`,
);
document.getElementById("text-eqn-energy").innerHTML = katex.renderToString(
`\\displaystyle\\textrm{Energy}=\\frac{\\hbar^2 n_x^2}{2ma^2}+\\frac{\\hbar^2 n_y^2}{2mb^2}`,
);
// document.getElementById("text-eqn-amplitude").innerHTML = katex.renderToString(
// 	`\\displaystyle A=\\textrm{Amplitude}=\\sqrt{\\frac{2}{L_x}}\\sqrt{\\frac{2}{L_y}}`,
// );
}
const X_MIN = 0;
const X_MAX = 1;
const X_WIDTH = X_MAX - X_MIN;
const Y_MIN = 0;
const Y_MAX = 1;
const Y_WIDTH = Y_MAX - Y_MIN;
const MIN_VAL = 0.25;
const plot = document.getElementById("plot");
const triangulationInfo = (() => {
const xMin = X_MIN;
const xMax = X_MAX;
const nXPoints = 101;
const dx = (xMax - xMin) / (nXPoints - 1);
const yMin = Y_MIN;
const yMax = Y_MAX;
const nYPoints = 103;
const dy = (yMax - yMin) / (nYPoints - 1);
const gridPoints = [];
for (let i = 0; i < nXPoints; ++i) {
const x = xMin + i * dx;
for (let j = 0; j < nYPoints; ++j) {
const y = yMin + j * dy;
gridPoints.push([x, y, null]);
}
}
const xs = gridPoints.map(p => p[0]);
const ys = gridPoints.map(p => p[1]);
const delaunay = d3.Delaunay.from(gridPoints);
const { triangles } = delaunay;
const i = d3.range(triangles.length / 3).map(i => triangles[3 * i]);
const j = d3.range(triangles.length / 3).map(i => triangles[3 * i + 1]);
const k = d3.range(triangles.length / 3).map(i => triangles[3 * i + 2]);
return { gridPoints, xs, ys, i, j, k };
})();
function getXScale(lx) {
const dx = (X_WIDTH - lx) / 2;
return d3.scaleLinear([X_MIN, X_MAX], [X_MIN + dx, X_MAX - dx]);
}
function getYScale(ly) {
const dy = (Y_WIDTH - ly) / 2;
return d3.scaleLinear([Y_MIN, Y_MAX], [Y_MIN + dy, Y_MAX - dy]);
}
function getScaledTriangulationInfo(lx, ly) {
const xScale = getXScale(lx);
const yScale = getYScale(ly);
const { i, j, k } = triangulationInfo;
let { gridPoints, xs, ys } = triangulationInfo;
gridPoints = gridPoints.map(([x, y, z]) => [xScale(x), yScale(y), z]);
xs = xs.map(x => xScale(x));
ys = ys.map(y => yScale(y));
return { gridPoints, xs, ys, i, j, k };
}
function waveFunction(x, y, { nx, ny, lx, ly }) {
return (
(2 / lx) ** 0.5 *
(2 / ly) ** 0.5 *
Math.sin((Math.PI * nx * x) / lx) *
Math.sin((Math.PI * ny * y) / ly)
);
}
let currNx = 1,
currNy = 1,
currLx = 1,
currLy = 1,
firstPlot = true;
function update({ nx, ny, lx, ly } = {}) {
if (nx === undefined) {
nx = currNx;
} else {
currNx = nx;
}
if (ny === undefined) {
ny = currNy;
} else {
currNy = ny;
}
if (lx === undefined) {
lx = currLx;
} else {
currLx = lx;
}
if (ly === undefined) {
ly = currLy;
} else {
currLy = ly;
}
const dx = X_WIDTH * ((X_MAX - lx) / 2);
const xMin = X_MIN + dx;
const xMax = X_MAX - dx;
const dy = (Y_WIDTH * (Y_MAX - ly)) / 2;
const yMin = Y_MIN + dy;
const yMax = Y_MAX - dy;
const surfaceLighting = {
ambient: 0.7,
roughness: 0.8,
diffuse: 0.4,
specular: 0.96,
};
const triangulationInfo = getScaledTriangulationInfo(lx, ly);
const zs = triangulationInfo.gridPoints.map(([x, y]) =>
waveFunction(x - dx, y - dy, { nx, ny, lx, ly }),
);
const maxZPossible = 2 / MIN_VAL;
const maxZObtained = d3.max(zs);
const meshDatum = {
type: "mesh3d",
x: triangulationInfo.xs,
y: triangulationInfo.ys,
z: zs,
i: triangulationInfo.i,
j: triangulationInfo.j,
k: triangulationInfo.k,
lighting: surfaceLighting,
facecolor: triangulationInfo.i.map(() => STANDARD_COLORS.graphicPrimary),
};
const gridlineZShift = 0.004;
const xGridlines = getGridlines({
nGridlines: 17,
xMin,
xMax,
yMin,
yMax,
nPointsPerGridline: 103,
zFunc: (x, y) =>
waveFunction(x - dx, y - dy, { nx, ny, lx, ly }) + gridlineZShift,
});
const yGridlines = getGridlines({
nGridlines: 17,
xMin: yMin,
xMax: yMax,
yMin: xMin,
yMax: xMax,
nPointsPerGridline: 103,
}).map(gridline =>
gridline.map(([x, y]) => [
y,
x,
waveFunction(x - dy, y - dx, { nx: ny, ny: nx, lx: ly, ly: lx }),
]),
);
const gridlinesData = [...xGridlines, ...yGridlines].map(gridline => ({
type: "scatter3d",
x: gridline.map(p => p[0]),
y: gridline.map(p => p[1]),
z: gridline.map(p => p[2]),
mode: "lines",
line: {
color: "#000",
width: 2.5,
},
}));
const zRange = maxZPossible * 1.3;
// const BOUND_SHIFT = 0.004;
// const boundingVertices = [
// 	// Bottom
// 	[X_MIN, Y_MIN, -zRange],
// 	[X_MIN, Y_MAX - BOUND_SHIFT, -zRange],
// 	[X_MAX - BOUND_SHIFT, Y_MAX - BOUND_SHIFT, -zRange],
// 	[X_MAX - BOUND_SHIFT, Y_MIN, -zRange],
// 	// Left
// 	[X_MIN, Y_MAX, -zRange + BOUND_SHIFT],
// 	[X_MIN, Y_MAX, zRange],
// 	[X_MAX - BOUND_SHIFT, Y_MAX, zRange],
// 	[X_MAX - BOUND_SHIFT, Y_MAX, -zRange + BOUND_SHIFT],
// 	// Right
// 	[X_MAX, Y_MIN, -zRange + BOUND_SHIFT],
// 	[X_MAX, Y_MIN, zRange],
// 	[X_MAX, Y_MAX - BOUND_SHIFT, zRange],
// 	[X_MAX, Y_MAX - BOUND_SHIFT, -zRange + BOUND_SHIFT],
// 	// [X_MIN, Y_MAX, zRange],
// 	// [X_MAX, Y_MIN, -zRange],
// 	// [X_MAX, Y_MIN, zRange],
// 	// [X_MAX, Y_MAX, -zRange],
// 	// [X_MAX, Y_MAX, zRange],
// ];
// const boundingTriangles = [
// 	// Bottom
// 	[0, 1, 2],
// 	[0, 2, 3],
// 	// Left
// 	[4, 5, 6],
// 	[4, 6, 7],
// 	// Top
// 	[8, 9, 10],
// 	[8, 10, 11],
// ];
// const barrierVertices = [
// 	// Left near face
// 	[X_MIN, yMax, -zRange],
// 	[X_MIN, yMax, zRange],
// 	[X_MIN, Y_MAX, -zRange],
// 	[X_MIN, Y_MAX, zRange],
// 	// Left far face
// 	[xMax, yMax, -zRange],
// 	[xMax, yMax, zRange],
// 	[xMax, Y_MAX, -zRange],
// 	[xMax, Y_MAX, zRange],
// 	// Right near face
// 	[xMax, Y_MIN, -zRange],
// 	[xMax, Y_MIN, zRange],
// 	[X_MAX, Y_MIN, -zRange],
// 	[X_MAX, Y_MIN, zRange],
// 	// Right far face
// 	[X_MAX, yMax, -zRange],
// 	[X_MAX, yMax, zRange],
// ];
// const barrierIndices = [
// 	//// Left
// 	// -z
// 	[0, 2, 4],
// 	[2, 4, 6],
// 	// -y
// 	[0, 4, 5],
// 	[0, 1, 5],
// 	// -x
// 	[0, 2, 3],
// 	[0, 1, 3],
// 	// +x
// 	[4, 5, 6],
// 	[5, 6, 7],
// 	// +y
// 	// Don't add duplicate faces to avoid z-fighting (y-fighting?)
// 	...(yMax === Y_MAX
// 		? []
// 		: [
// 				[2, 3, 6],
// 				[3, 6, 7],
// 		  ]),
// 	// +z
// 	[1, 3, 5],
// 	[3, 5, 7],
// 	//// Right
// 	// -z
// 	[4, 8, 10],
// 	[4, 10, 12],
// 	// -y
// 	[4, 8, 9],
// 	[4, 5, 9],
// 	// -x
// 	[8, 9, 10],
// 	[9, 10, 11],
// 	// +x
// 	// Don't add duplicate faces to avoid z-fighting (x-fighting?)
// 	...(xMax === X_MAX
// 		? []
// 		: [
// 				[10, 11, 12],
// 				[12, 11, 13],
// 		  ]),
// 	// +y
// 	[4, 5, 12],
// 	[5, 12, 13],
// 	// +z
// 	[5, 9, 11],
// 	[5, 11, 13],
// ];
// const barrierDatum = {
// 	type: "mesh3d",
// 	x: barrierVertices.map(p => p[0]),
// 	y: barrierVertices.map(p => p[1]),
// 	z: barrierVertices.map(p => p[2]),
// 	i: barrierIndices.map(i => i[0]),
// 	j: barrierIndices.map(i => i[1]),
// 	k: barrierIndices.map(i => i[2]),
// 	flatshading: true,
// 	lighting: { facenormalepsilon: 0, ambient: 0.4, specular: 0.5, diffuse: 0.3 },
// 	facecolor: boundingTriangles.map(() => "#555"),
// };
// const boundingVertices = [];
// const boundingTriangles = [];
// for (const { indices, face } of boundingTrianglesUnshifted) {
// 	const vertices = indices.map(i => [...boundingVerticesUnshifted[i]]);)
// 	if (face === "xy") {
// 		for (const vertex of vertices){
// 			if (vertex===)
// 		}
// 	}
// }
// const boundingSurface = {
// 	type: "mesh3d",
// 	x: boundingVertices.map(p => p[0]),
// 	y: boundingVertices.map(p => p[1]),
// 	z: boundingVertices.map(p => p[2]),
// 	i: boundingTriangles.map(t => t[0]),
// 	j: boundingTriangles.map(t => t[1]),
// 	k: boundingTriangles.map(t => t[2]),
// 	flatshading: true,
// 	lighting: { facenormalepsilon: 0 },
// 	facecolor: boundingTriangles.map(() => "#000"),
// };
const dd = 0.002;
const boundingLines = [
// Bottom square
[
[xMin, yMin, -zRange],
[xMin, yMax, -zRange],
],
[
[xMin, yMax, -zRange],
[xMax, yMax, -zRange],
],
[
[xMax, yMax, -zRange],
[xMax, yMin, -zRange],
],
[
[xMax, yMin, -zRange],
[xMin, yMin, -zRange],
],
// Left square (minus the edge it shares with the bottom one)
[
[xMax, yMax, -zRange],
[xMax, yMax, zRange],
],
[
[xMax, yMax, zRange],
[xMin, yMax, zRange],
],
[
[xMin, yMax, zRange],
[xMin, yMax, -zRange],
],
// Right square (minus the two edges it shares with the other two)
[
[xMax, yMax, zRange],
[xMax, yMin, zRange],
],
[
[xMax, yMin, zRange],
[xMax, yMin, -zRange],
],
].map(points => ({
type: "scatter3d",
mode: "lines",
x: points.map(p => {
const x = p[0];
return x === X_MIN ? x : x - dd;
}),
y: points.map(p => {
const y = p[1];
return y === Y_MIN ? y : y - dd;
}),
z: points.map(p => {
const z = p[2];
return z < 0 ? z + dd : z;
}),
line: {
width: 5,
color: "#bbb",
},
}));
const AXIS_LINE_THICKNESS = 5;
const AXIS_COLOR = "#bbb";
// const axisLines = [
// 	// Far lines
// 	// [
// 	// 	[X_MAX, Y_MAX, -zRange],
// 	// 	[X_MIN, Y_MAX, -zRange],
// 	// ],
// 	// [
// 	// 	[X_MAX, Y_MAX, -zRange],
// 	// 	[X_MAX, Y_MIN, -zRange],
// 	// ],
// 	// [
// 	// 	[X_MAX, Y_MAX, -zRange],
// 	// 	[X_MAX, Y_MAX, zRange],
// 	// ],
// 	// Others
// 	[
// 		[X_MAX, Y_MAX, zRange],
// 		[X_MIN, Y_MAX, zRange],
// 	],
// 	[
// 		[X_MIN, Y_MAX, zRange],
// 		[X_MIN, Y_MAX, -zRange],
// 	],
// 	[
// 		[X_MAX, Y_MAX, zRange],
// 		[X_MAX, Y_MIN, zRange],
// 	],
// 	[
// 		[X_MAX, Y_MIN, zRange],
// 		[X_MAX, Y_MIN, -zRange],
// 	],
// 	[
// 		[X_MAX, Y_MIN, -zRange],
// 		[xMax, Y_MIN, -zRange],
// 	],
// 	[
// 		[X_MIN, Y_MAX, -zRange],
// 		[X_MIN, yMin, -zRange],
// 	],
// ].map(points => ({
// 	type: "scatter3d",
// 	mode: "lines",
// 	x: points.map(p => p[0]),
// 	y: points.map(p => p[1]),
// 	z: points.map(p => p[2]),
// 	line: {
// 		width: AXIS_LINE_THICKNESS - 1,
// 		color: AXIS_COLOR,
// 	},
// }));
const TICK_LENGTH = 0.03;
const LABEL_DIST_FROM_TICK = 0.05;
const axisTicksAndLabelsInfo = [
// x axis ticks
{ point: [xMin, yMin, -zRange], dir: "y", label: "0" },
{ point: [xMax, yMin, -zRange], dir: "y", label: "ùëé" },
// y axis ticks
{ point: [xMin, yMin, -zRange], dir: "x", label: "0" },
{ point: [xMin, yMax, -zRange], dir: "x", label: "ùëè" },
// z axis ticks
{ point: [xMin, yMax, -maxZObtained], dir: "x", label: "-ùê¥" },
{ point: [xMin, yMax, 0], dir: "x", label: "0" },
{ point: [xMin, yMax, maxZObtained], dir: "x", label: "ùê¥" },
];
const axisTicks = [];
const axisLabels = [];
for (const { point, dir, label } of axisTicksAndLabelsInfo) {
const tickP1 = point;
const tickP2 = [...point];
const dirIndex = dir === "x" ? 0 : dir === "y" ? 1 : 2;
tickP2[dirIndex] -= TICK_LENGTH;
const labelPoint = [...tickP2];
labelPoint[dirIndex] -= LABEL_DIST_FROM_TICK;
const points = [tickP1, tickP2];
axisTicks.push({
type: "scatter3d",
mode: "lines",
x: points.map(p => p[0]),
y: points.map(p => p[1]),
z: points.map(p => p[2]),
line: {
width: AXIS_LINE_THICKNESS,
color: "#ccc",
},
});
axisLabels.push({
type: "scatter3d",
mode: "text",
x: [labelPoint[0]],
y: [labelPoint[1]],
z: [labelPoint[2]],
text: [label],
textposition: "middle center",
textfont: {
size: 20,
color: "white",
},
});
}
const data = [
meshDatum,
...gridlinesData,
...boundingLines,
// ...axisLines,
...axisTicks,
...axisLabels,
// barrierDatum,
];
const axesAttrs = {
visible: true,
showgrid: false,
showline: false,
showspikes: false,
ticks: false,
linewidth: AXIS_LINE_THICKNESS,
gridwidth: AXIS_LINE_THICKNESS,
zerolinewidth: AXIS_LINE_THICKNESS,
mirror: false,
tickfont: { size: 16 },
zeroline: false,
showticklabels: false,
color: AXIS_COLOR,
gridcolor: "#999",
};
const TOTAL_TICK_LENGTH = TICK_LENGTH + LABEL_DIST_FROM_TICK;
const layout = {
width: 800,
height: 800,
paper_bgcolor: "black",
margin: { t: 0, b: 0, l: 0, r: 0 },
hovermode: false,
showlegend: false,
scene: {
aspectmode: "manual",
aspectratio: { x: 1.3, y: 1.3, z: 0.8 },
xaxis: {
...axesAttrs,
title: "",
range: [X_MIN - TOTAL_TICK_LENGTH, X_MAX + TOTAL_TICK_LENGTH],
},
yaxis: {
...axesAttrs,
title: "",
range: [Y_MIN - TOTAL_TICK_LENGTH, Y_MAX + TOTAL_TICK_LENGTH],
},
zaxis: {
...axesAttrs,
title: "",
showgrid: false,
range: [-zRange, zRange],
},
},
};
if (firstPlot) {
const cameraXYDist = 2.3;
const cameraInitialAngle = (3 * Math.PI) / 2 - 0.4;
const x = cameraXYDist * Math.cos(cameraInitialAngle);
const y = cameraXYDist * Math.sin(cameraInitialAngle);
layout.scene.camera = {
up: { x: 0, y: 0, z: 1 },
center: { x: 0, y: 0, z: 0 },
eye: {
x,
y,
z: 1.1,
},
projection: { type: "perspective" },
};
firstPlot = false;
} else {
layout.scene.camera = plot._fullLayout.scene._scene.getCamera();
}
const config = {
displayModeBar: false,
scrollZoom: false,
};
Plotly.react(plot, data, layout, config);
}
const SLIDER_STEP = 0.001;
d3.select("#slider-lx")
.each(function () {
this.min = MIN_VAL;
this.max = X_MAX;
this.step = SLIDER_STEP;
this.value = X_MAX;
})
.on("input", function () {
update({ lx: +this.value });
});
d3.select("#slider-ly")
.each(function () {
this.min = MIN_VAL;
this.max = Y_MAX;
this.step = SLIDER_STEP;
this.value = Y_MAX;
})
.on("input", function () {
update({ ly: +this.value });
});
d3.selectAll(".n-button").each(function () {
const n = this.getAttribute("wavenumber");
const axis = this.getAttribute("axis");
const key = axis === "x" ? "nx" : "ny";
d3.select(this).on("click", () => update({ [key]: n }));
});
update({});
</script></body>
</html>