(* :Title:	Arg Color Plot *)(* :Name:	Graphics`ArgColorPlot` *)(* :Author:	Bernd Thaller,			Institute of Mathematics,			University of Graz,			A-8010 Graz			bernd.thaller@kfunigraz.ac.at*)(* :Summary: 	Plot the absolute value Abs[f[x]] of a complex-valued	function f depending on a real variable x and	fill the space between the plotted function	and the x-axis with a color corresponding to the argument	Arg[f[x]]. The saturation and brightness	of the colors can be set using the options Saturation	and Brightness.*)(* :Package Version:		1.8 	Changed behavior of Compile	Introduced BottomLine and ShiftPlot option.	Added the option HRange for ListArgColorPlot.	Added the commands SpinorPlot and ListSpinorPlot for plotting	C^2-valued functions.	Added ListArgColorPlot for lists {{x1,z1},{x2,z2},...}	Some simplifications for ArgColorPlot etc.	Added SpinorCombinedPlot*)(* :Date:	2001-06-07 *)(* :Mathematica Version:	4.0 *)(* :Copyright: Copyright 1997-2001 by Bernd Thaller *)(* :Keywords:	graphics, Plot, area under the curve, ArgColors*)    (* :Examples:		Off[Arg::indet];	    ArgColorPlot[Exp[-I 6 x - x^2/2], {x,-4,4}];    ArgColorPlot[Exp[-I 6 x - x^2/2], {x,-4,4},           PlotStyle -> {Thickness[0.025],GrayLevel[0.5]},           Saturation -> .5, Brightness->.7,           PlotRange -> {-.2,1.2}, Frame -> True,           Axes->{True,False}]        mytab = Table[Sin[Pi x] Exp[2 I Pi x], {x,-2,2,.1}];    ListArgColorPlot[mytab, Axes->True, HRange->{-2,2}];    ListArgColorPlot[mytab, Axes->True, HRange->{{-2,2},{-1,0}}];    ListArgColorPlot[mytab, Axes->True, HRange->{{-2,2},{-4,4}}];        CombinedPlot[{Sin[Pi x],Sin[Pi x]}, {x,-4,3}];    mytab = Table[Sin[Pi x], {x,-4,3,.1}];    ListCombinedPlot[{mytab,Sin[Pi x]}, {x,-4,3}];	ListCombinedPlot[{mytab,Sin[Pi x]}, {x,0,3}];    ListCombinedPlot[{mytab,Sin[Pi x]}, {x,0,3}, HRange->{-4,3}];    ListCombinedPlot[{mytab,Sin[Pi x]}, {x,0,3}, HRange->{{-4,3},{1,2}}];        Show[	ArgColorPlot[Sin[x+I], {x,-3,3},		BottomLine->1, Epilog->Line[{{-3,1},{3,1}}],		DisplayFunction->Identity],	ArgColorPlot[Cos[x+I] - Exp[I Arg[Cos[x+I]]], {x,-3,3},		DisplayFunction->Identity],	PlotRange->{-.2,1.7}, Frame->True,	DisplayFunction->$DisplayFunction]		spinorfunction[x_] := {Cos[3 x] Exp[-(x-1/4)^2/3+I  x ],      	Sin[4x]  Exp[-(x+1/4)^2/2+2 I x ]};	SpinorPlot[Evaluate[spinorfunction[x]], {x,-3.,3.},		PlotRange->All, Frame->True, Axes->{True,False}]		spinorlist = Table[{x,spinorfunction[x]},{x,-3,3,.1}];	ListSpinorCombinedPlot[{spinorlist,Sin[4 x]},		{x,-2,3}, PlotRange->All,		CurveStyle->{RGBColor[0,.7,.9],Thickness[0.03]},		PlotStyle->{RGBColor[.2,.2,.5],Thickness[0.02]}]*)    BeginPackage[    "Graphics`ArgColorPlot`",    "Graphics`FilledPlot`",     (* draw axes in front *)    "Utilities`FilterOptions`",    "Graphics`Graphics`",    "Global`"]  ;                (* prevent shadowing *)Unprotect[ArgColorPlot,    ListArgColorPlot, CombinedPlot,    ListCombinedPlot, SpinorPlot, ListSpinorPlot,     SpinorCombinedPlot, ListSpinorCombinedPlot,    NiceTicks, Saturation, Brightness, BottomLine,    ShiftPlot, HRange, PlotDown, Squared, CurveStyle];Clear[ArgColorPlot,    ListArgColorPlot, CombinedPlot,    ListCombinedPlot, SpinorPlot, ListSpinorPlot,     SpinorCombinedPlot, ListSpinorCombinedPlot,    NiceTicks, Saturation, Brightness, BottomLine,    ShiftPlot, HRange, PlotDown, Squared, CurveStyle];    ArgColorPlot::usage = "ArgColorPlot[f[x],{x,x0,x1},opts] is usedlike the usual Plot command. It gives a two-dimensional plotof a complex-valued function f of a single real variable xin the range {x0,x1}.The plot shows the curve Abs[f] with area between the curveand the x-axis colored by Hue[Arg[f[x]]/(2 Pi)].The default options of Plot are changed to Axes->{True,None},Fame->True.";ListArgColorPlot::usage = "ListArgColorPlot[f,{x,x0,x1},opts]plots a Abs[f], where f is a list of complex numbers. The points of the list Abs[f] are joined by a line.The area between the curve and the x-axis is colored at eachpoint by Hue[Arg[f]/(2 Pi)].";CombinedPlot::usage = "CombinedPlot[{f[x],g[x]},{x,x0,x1},opts]works like ArgColorPlot with respect to f. The curve g is drawnin front of the ArgColorPlot of f";ListCombinedPlot::usage = "ListCombinedPlot[{list,f[x]},{x,x0,x1},opts]works like ListArgColorPlot with respect to list.It is assumed that list represents the discretized values of a functiondefined on the interval [x0,x1]. The color list plotis then combined with an ordinary plot of f on the same scale andwith the Ticks automatically adjusted.";SpinorPlot::usage = "SpinorPlot[{func1,func2},{x,x0,x1},opts] provides amethod to visualize C^2-valued functions (for example, spinor wavefunctionsin quantum mechanics). The SpinorPlot combines an ArgColorPlot of func1with an ArgColorPlot of func2 (upside down, with less saturation)Both curves are plotted with the option Squared->True (that is, a plotof the curve Abs[func]^2 is filled with a color describing the phase).In the background, a filled plot of Abs[func1]^2 + Abs[func2]^2displays the corresponding density.";ListSpinorPlot::usage = "ListSpinorPlot[{list1,list2},opts] visualizestwo lists of complex numbers. See the description of SpinorPlot.";SpinorCombinedPlot::usage = "SpinorCombinedPlot[{func1,func2},{x,x0,x1},opts]combines a SpinorPlot of func1 with an ordinary Plot of a real-valued function func2.See the description of CombinedPlot andof SpinorPlot.";ListSpinorCombinedPlot::usage = "ListSpinorCombinedPlot[{list1,list2},opts]";NiceTicks::usage = "NiceTicks[xmin,xmax,dx] provides a list of nice positionsfor use in the Ticks or FrameTicks option in a ListPlot, where it is assumedthat the list of values ranges between xmin and xmax in steps dx.";Saturation::usage = "Option for ArgColorPlot. Saturation->s causes the colorsin the plot to appear at saturation s. Default value is 1.";Brightness::usage = "Option for ArgColorPlot. Brightness->b causes the colorsto be drawn at brightness b. Default value is 1.";BottomLine::usage = "Option for ArgColorPlot.BottomLine->number fills the region between the graph ofthe function and the horizontal line at y=number";ShiftPlot::usage = "Option for ArgColorPlot. ShiftPlot->number performs a verticalshift of the whole plot by number";HRange::usage = "Option for ListArgColorPlot that describes the range ofcoordinates on the horizontal axis. HRange->{{x1,x2},{y1,y2}} means thatthe list represents values given on a regular grid of points inthe interval [x1,x2]. The interval [y1,y2] is the visible coordinate rangeon the horizontal axis. Ticks for axes or frame are defined automatically.If [y1,y2] is larger than [x1,x2], then the list is padded with zeros.HRange->{x1,x2} can be used as a shortcut for HRange->{{x1,x2},{x1,x2}}.";PlotDown::usage = "Option for ArgColorPlot. If set to True, the plot is 'upside down',that is, the graph is drawn in the negative y-direction";Squared::usage = "Option for ArgColorPlot. If set to True, then the graph showsthe absolute square of the function, otherwise the graph shows theabsolute value.";CurveStyle::usage = "Option for CombinedPlot. Controls how the curve representingthe real function is drawn. Works like PlotStyle, which affects onlythe complex part.";Begin["`Private`"];Options[ArgColorPlot] = Join[Options[Plot],{AxesFront->True, Saturation->1,Brightness->1, BottomLine->0, ShiftPlot->0, PlotDown->False, Squared->False}];Options[ListArgColorPlot] = Join[Options[ArgColorPlot],{HRange->All}];SetAttributes[ArgColorPlot,HoldAll];ArgColorPlot[func_,{x_Symbol,xmin_,xmax_},opts___] :=	Module[{comp,plot1,plot2,plot3,opts1,			xvars1,xvars2,xvars3,xvars,yvals},        comp = Compiled/.{opts}/.Options[ArgColorPlot];        If[comp == True,          fnc = Compile[{x},func,{{func,_Complex}}], (*else*)          fnc = Function[{x},func];        ];        opts1   = FilterOptions[Plot,                  JoinOptions[DisplayFunction->Identity,opts]];		plot1	= Plot[Abs[func],{x,xmin,xmax}, Evaluate[opts1]];		plot2	= Plot[ Re[func],{x,xmin,xmax}, Evaluate[opts1]];		plot3	= Plot[ Im[func],{x,xmin,xmax}, Evaluate[opts1]];		xvars1	= First /@ Level[plot1[[1]],{4}];Remove[plot1];        xvars2	= First /@ Level[plot2[[1]],{4}];Remove[plot2];        xvars3	= First /@ Level[plot3[[1]],{4}];Remove[plot3];        xvars	= Union[xvars1,xvars2,xvars3];Remove[xvars1,xvars2,xvars3];        yvals   = fnc /@ xvars;        ListArgColorPlot[{xvars,yvals}//Transpose, opts]	]/;NumberQ[N[xmin]] && NumberQ[N[xmax]]ListArgColorPlot[list_List,opts___] :=	Module[{ran, auxopts},		ran = HRange/.{opts}/.Options[ListArgColorPlot];		If[MatchQ[N[ran],{_?NumberQ,_?NumberQ}],ran = {ran,ran}];		If[MatchQ[N[ran],{{_?NumberQ,_?NumberQ},{_?NumberQ,_?NumberQ}}],			xvars = Range[ran[[1,1]],ran[[1,2]],(ran[[1,2]]-ran[[1,1]])/(Length[list]-1)];			auxopts = JoinOptions[HRange->{ran[[2,1]],ran[[2,2]]},opts];,			xvars	= Range[Length[list]];			auxopts = opts		];		ListArgColorPlot[{xvars,list}//Transpose, auxopts]	]/;VectorQ[list]ListArgColorPlot[list_List,opts___] :=	Module[{sat,bri,style,dir,squ,bl,nbl,sh,shift,ran,			xvars = First /@ list,			yvals = Last /@ list,			hues, auxlist,			optsWithDefaults = JoinOptions[{opts},{Axes->True, AxesFront->True}]},		If[Not[And @@ (NumberQ[#]& /@ Flatten[N[list]])],			Message[LACP::listform]; Return[] ];		{sat,bri,style,dir,squ,bl,sh,ran} =			{Saturation,Brightness,PlotStyle,PlotDown,Squared,			 BottomLine,ShiftPlot,HRange}/.{opts}/.Options[ListArgColorPlot];        nbl    = If[NumberQ[N[bl]],N[bl],0.,0.];        shift  = If[NumberQ[N[sh]],N[sh],0.,0.];		If[MatchQ[N[ran],{{_?NumberQ,_?NumberQ},{_?NumberQ,_?NumberQ}}],			ran = ran[[2]] ];		If[MatchQ[N[ran],{_?NumberQ,_?NumberQ}],			auxlist = TrimList[list,{ran[[1]],ran[[2]]}];			xvars	= First /@ auxlist;         	yvals	= Last /@ auxlist; Remove[auxlist];         ];         hues	= Hue[Mod[Arg[#]/(2 Pi),1],sat,bri]& /@ yvals;         yvals	= If[squ==True, Abs[yvals]^2, Abs[yvals], Abs[yvals]];         yvals	= If[dir == True, -1*yvals, yvals, yvals];         Show[fillit[xvars,hues,yvals,style,nbl,shift],             Evaluate[FilterOptions[Graphics,optsWithDefaults]]         ]   ]/;(Dimensions[list] == {Length[list],2})ListArgColorPlot[sillyArgument_,opts___] :=    Message[LACP::listform]SetAttributes[SpinorPlot,HoldAll];SpinorPlot[{func1_,func2_},{x_Symbol,xmin_,xmax_},opts___] :=	Module[{},		Show[			ArgColorPlot[Sqrt[Abs[func1]^2 + Abs[func2]^2], {x,xmin,xmax},				DisplayFunction->Identity,				Saturation->0, Brightness->1/4, opts],			ArgColorPlot[func1, {x,xmin,xmax},				DisplayFunction->Identity, opts],			ArgColorPlot[func2, {x,xmin,xmax},				DisplayFunction->Identity,				PlotDown->True, opts, Saturation->1/2],			Evaluate[FilterOptions[Graphics,opts]],			DisplayFunction->$DisplayFunction  		]  	]/;NumberQ[N[xmin]] && NumberQ[N[xmax]]ListSpinorPlot[{list1_List,list2_List},opts___] :=	Module[{},		If[Length[list1]!=Length[list2],Message[LSP::unequal];Return[]];		If[!VectorQ[list1],Message[LSP::listform];Return[]];		If[!VectorQ[list2],Message[LSP::listform];Return[]];		Show[			ListArgColorPlot[Sqrt[Abs[list1]^2 + Abs[list2]^2],				DisplayFunction->Identity,				Saturation->0, Brightness->1/4, opts],			ListArgColorPlot[list1,				DisplayFunction->Identity, opts],			ListArgColorPlot[list2,				DisplayFunction->Identity,				PlotDown->True, opts, Saturation->1/2],			Evaluate[FilterOptions[Graphics,opts]],     		DisplayFunction->$DisplayFunction		]	]ListSpinorPlot[list_,opts___] := 	ListSpinorPlot[list//Transpose, opts	]/;((Dimensions[list] == {Length[list],2}) && Length[list]>2 && VectorQ[Last/@list])ListSpinorPlot[list_,opts___] := 		Show[			ListArgColorPlot[{First /@ list,					Sqrt[Abs[First /@ Last /@ list]^2 +					Abs[Last  /@ Last /@ list]^2]}//Transpose,				DisplayFunction->Identity,				Saturation->0, Brightness->1/4, opts],			ListArgColorPlot[{First /@ list,First /@ Last /@ list}//Transpose,				DisplayFunction->Identity, opts],			ListArgColorPlot[{First /@ list,Last  /@ Last /@ list}//Transpose,				DisplayFunction->Identity,				PlotDown->True, opts, Saturation->1/2],			Evaluate[FilterOptions[Graphics,opts]],     		DisplayFunction->$DisplayFunction		]/;MatchQ[ N[list],{{_?NumberQ,{_?NumberQ,_?NumberQ}},__}]LSP::unequal = "The two lists of complex numbers must be of equal length";LACP::listform = "The first argument of ListArgColorPlot must be a one-dimensional listof complex numbers zi, or a list of the form {{x1,z1},{x2,z2},...}";LSP::listform = "One of the arguments is not a one-dimensional list of complex numbers";Options[CombinedPlot] = Join[Options[ArgColorPlot], {CurveStyle->Automatic}];Options[ListCombinedPlot] = Join[Options[ListArgColorPlot], {CurveStyle->Automatic}];CombinedPlot[{func1_,func2_},             {x_Symbol,xmin_,xmax_},             opts___Rule] :=	Module[{ps = CurveStyle/.{opts}/.Options[CombinedPlot], auxopts},		auxopts = JoinOptions[PlotStyle->ps, opts];		DisplayTogether[			ArgColorPlot[func1, {x,xmin,xmax},				Evaluate[FilterOptions[ArgColorPlot,opts]] ],			Plot[func2, {x,xmin,xmax},				Evaluate[FilterOptions[Plot,auxopts]] ],			Evaluate[FilterOptions[Graphics,opts]]]     ] /; NumberQ[N[xmin]] && NumberQ[N[xmax]]ListCombinedPlot[{list_List,func_},	{x_Symbol,xmin_,xmax_}, opts___Rule] :=Module[{ran,ps,auxopts},		{ran,ps} = {HRange,CurveStyle}/.{opts}/.Options[ListCombinedPlot];		If[MatchQ[N[ran],{_?NumberQ,_?NumberQ}],			ran = {ran,{xmin,xmax}}];		If[Not[MatchQ[N[ran],{{_?NumberQ,_?NumberQ},{_?NumberQ,_?NumberQ}}]],			ran = {{xmin,xmax},{xmin,xmax}} ];		auxopts = JoinOptions[PlotStyle->ps, opts];		DisplayTogether[            ListArgColorPlot[list,            	Evaluate[FilterOptions[ListArgColorPlot,            		JoinOptions[HRange->ran,opts]]] ],            Plot[func, {x,xmin,xmax},				Evaluate[FilterOptions[Plot,auxopts]] ],		    Evaluate[FilterOptions[Graphics,opts]]		]   ]/;NumberQ[N[xmin]] && NumberQ[N[xmax]]SpinorCombinedPlot[{func1_,func2_},             {x_Symbol,xmin_,xmax_},             opts___Rule] :=	Module[{ps = CurveStyle/.{opts}/.Options[CombinedPlot], auxopts},		auxopts = JoinOptions[PlotStyle->ps, opts];		DisplayTogether[			SpinorPlot[func1, {x,xmin,xmax},				Evaluate[FilterOptions[ArgColorPlot,opts]] ],			Plot[func2, {x,xmin,xmax},				Evaluate[FilterOptions[Plot,auxopts]] ],			Evaluate[FilterOptions[Graphics,opts]]]     ] /; NumberQ[N[xmin]] && NumberQ[N[xmax]]ListSpinorCombinedPlot[{list_List,func_},	{x_Symbol,xmin_,xmax_}, opts___Rule] :=Module[{ran,ps,auxopts},		{ran,ps} = {HRange,CurveStyle}/.{opts}/.Options[ListCombinedPlot];		If[MatchQ[N[ran],{_?NumberQ,_?NumberQ}],			ran = {ran,{xmin,xmax}}];		If[Not[MatchQ[N[ran],{{_?NumberQ,_?NumberQ},{_?NumberQ,_?NumberQ}}]],			ran = {{xmin,xmax},{xmin,xmax}} ];		auxopts = JoinOptions[PlotStyle->ps, opts];		DisplayTogether[            ListSpinorPlot[list,            	Evaluate[FilterOptions[ListArgColorPlot,            		JoinOptions[HRange->ran,opts]]] ],            Plot[func, {x,xmin,xmax},				Evaluate[FilterOptions[Plot,auxopts]] ],		    Evaluate[FilterOptions[Graphics,opts]]		]   ]/;NumberQ[N[xmin]] && NumberQ[N[xmax]](* auxiliary functions *)TrimList[list_,{xmin_,xmax_}] :=	Module[{x1 = First[list][[1]], xn = Last[list][[1]], auxlist=list},		auxlist = Select[list, (xmin <= First[#] <= xmax)& ];		If[xmin < x1, auxlist = Join[{{xmin,0},{x1,0}},auxlist] ];		If[xmax > xn, auxlist = Join[auxlist,{{xn,0},{xmax,0}}] ];		auxlist ]/;(Dimensions[list] == {Length[list],2})NiceTicks[xmin_,xmax_,dx_,n_:8] :=   convertticks[LinearScale[xmin,xmax,n],xmin,dx] /;   NumberQ[N[xmin]] && NumberQ[N[xmax]] && NumberQ[N[dx]]convertticks[list_,xmin_,dx_]:=   Module[{res=list,a,myind},          myind[x_] = ind[x,xmin,dx];          Do[             a = res[[i]];             If[Head[a]===List,                res[[i]]=                If[Head[a[[2]]]===List,                   res[[i]]=Join[{myind[a[[1]]],a[[1]]},Take[a,1-Length[a]]],                   res[[i]]=ReplacePart[a,myind[a[[1]]],1]],                res[[i]]={myind[a],a}             ],          {i,Length[res]}];          res   ]ind[x_,xmin_,dx_] := N[((x-xmin)/dx)+1];(* This plots the filled curve: *)fillit[xvars_,hues_,values_,style_,bl_,sh_] :=   Module[{nullv,xpts,valpts,lines,fills,shvar},      nullv = Table[bl,{Length[xvars]}];      shvar = Table[sh,{Length[xvars]}];      If[bl==0.,nullv=shvar];      xpts = {xvars,nullv}//Transpose;      valpts = {xvars,values+shvar}//Transpose;      If[style === Automatic,          lines = Line[valpts], (*else*)          lines = Flatten[{style, Line[valpts]}]      ];      fills =         {Drop[hues,-1],             Map[Polygon,               { Drop[xpts,-1], Drop[valpts,-1], Drop[valpts,1], Drop[xpts, 1]                    }//Transpose             ]         }//Transpose;      Graphics[ {fills,lines} ]   ](* ------ dealing with options ------ *)(* joining two lists of rules with list1 having precedenceover list2: *)JoinOptions[list1_,list2___]:=    Module[{namelist=First /@ Flatten[{list1}]},        Sequence @@        Sort[Join[Flatten[{list1}],            Select[Flatten[{list2}],                !MemberQ[namelist,First[#]]&]]        ]    ]End[];Protect[ArgColorPlot,    ListArgColorPlot, CombinedPlot,    ListCombinedPlot, SpinorPlot, ListSpinorPlot,     SpinorCombinedPlot, ListSpinorCombinedPlot,    NiceTicks, Saturation, Brightness, BottomLine,    ShiftPlot, HRange, PlotDown, Squared, CurveStyle];EndPackage[];